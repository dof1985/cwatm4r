#
#
#in
cwatm4r::raster2ncdf(rast_in = x, path_out = sprintf("%s/gswp3-w5e5_obsclim_%s_daily_1990_2019.nc", pthout, var),
name = var, is_ncdf4 = FALSE,
time = as.numeric(names(x)),
origin = "1900-01-01",
unit = inf$varAttributes.units, prec = "double", missing_value =  320000,
longname = inf$varAttributes.long_name,
institute = "IIASA", title = "CWatM-Israel: climate inputs")
}
sprintf("%s/gswp3-w5e5_obsclim_%s_daily_1990_2019.nc", pthout, var)
cwatm4r::ncdf2raster(sprintf("%s/gswp3-w5e5_obsclim_%s_daily_1990_2019.nc", pthout, var), transpose = TRUE, time = 1)
plot(cwatm4r::ncdf2raster(sprintf("%s/gswp3-w5e5_obsclim_%s_daily_1990_2019.nc", pthout, var), transpose = TRUE, time = 1))
devtools::document("c:/users/fridman/documents/GitHub/cwatm4r")
devtools::load_all("c:/users/fridman/documents/GitHub/cwatm4r")
#library(cwatm4r)
library(raster)
pthin <- "c:/Users/fridman/Dropbox/IIASA/cwatm-dataCollection/Israel_1km/CWATM_data/climate/GSWP3-W5E5_1990-2019/"
pthout <- "c:/Users/fridman/Dropbox/IIASA/cwatm-dataCollection/Israel_1km/CWATM_data/climate/GSWP3-W5E5/"
# load basemap
fls <- list.files(pthin, full.names = TRUE)[1]
basemap_pth <- "c:/Users/fridman/Dropbox/IIASA/cwatm-dataCollection/Israel_1km/CWATM_data/cwatm_input30sec/routing/ldd.nc"
basemap <- cwatm4r::ncdf2raster(basemap_pth, transpose = TRUE) > 0
fle_tmplt <-cwatm4r::ncdf2raster(fls, time = 1, transpose = TRUE)
# aggregate basemap
basemap <- aggregate(basemap, mean(res(fle_tmplt) / res(basemap))) > 0
vars <- na.omit(unique(unlist(lapply(strsplit(list.files(pthin), split = "_"), `[`, 3))))
#var <- vars[1]
#cwatm4r::ncdfInfo(fls, attrs =
var = "pr"
print(var)
fls <- list.files(pthin, pattern = var, full.names = TRUE)
x <- unlist(lapply(fls[2], function(fle) {
cwatm4r::ncdf2raster(pth = fle, transpose = TRUE, spatial = basemap)
}), recursive = FALSE)
x <- unlist(lapply(fls[2], function(fle) {
cwatm4r::ncdf2raster(pth = fle, transpose = TRUE, spatial = basemap, time = c(1, 10))
}), recursive = FALSE)
x
(34.5-33)/0.5
9/(34.5-33)
(34.5-33)/9
(34.5-33)/11
5/11
5/9
34.5-28.5
(34.5-28.5) / 11
(34.5-28.5) / 0.5
0.5/11
11/0.5
0.5/11
(34.5-28.5)/11
0.5*11
#cwatm4r::ncdfInfo(fls, attrs = TRUE)
pth = fls[2]; transpose = TRUE; spatial = basemap; time = c(1, 2); flip = NULL; fun = NULL; temporal_fun = NULL; origin = "1900-01-01";crs = "+init=EPSG:4326";varName = NULL
## input validation
if(!is.null(time)) {
stopifnot("'time' argument should be of class 'Date', 'integer' or 'numeric'" = any(c("integer", "Date", "numeric") %in% class(time)))
stopifnot("'time' argument should be of length 1 or 2" = length(time) == 1 || length(time) ==2)
if(length(time) == 2) {
stopifnot("The first member of the 'time' argument should be smaller than its second member" = time[2] > time[1])
}
}
if(!is.null(spatial)) {
stopifnot("'spatial' argument should be of class 'RasterLayer' or 'data.frame'" = any(c("RasterLayer", "data.frame") %in% class(spatial)))
if(class(spatial) == "data.frame") {
cond <- all(c(any(c("lat", "Y", "y") %in% names(spatial)), any(c("lon", "X", "x") %in% names(spatial))))
stopifnot("Points coordinates columun should recieve one of the following names: c('x', 'y'), c('X', 'Y'), c('lon', 'lat')" = cond)
}
}
if(!is.null(varName)) {
stopifnot("'varName' should be of class 'character'" = class(varName) %in% "character")
}
if(!is.null(temporal_fun)) {
stopifnot("'temporal_fun' should be of class 'character'" = class(temporal_fun) %in% "character")
stopifnot("'temporal_fun' can recieve one of the following: 'sum', 'mean', 'sd', 'cv'" = temporal_fun %in% c("sum", "mean", "sd", "cv"))
}
## functions
getAxis <- function(array, idx, axis) {
ndim <- length(dim(array))
idx_list <- lapply(seq_len(ndim), function(d) {
if(d == axis) {
return(idx)
} else {
return(seq_len(dim(array)[d]))
}
})
return(do.call("[", c(list(array), idx_list)))
}
# open file
# open file
tmp <- ncdf4::nc_open(pth)
tmp
# get dim x, dim y
y <- tmp$dim$lat$vals
x <- tmp$dim$lon$vals
resx <- x[2] - x[1]
resy <- abs(y[2] - y[1])
# set temporal dim
timeExists <- "time" %in% names(tmp$dim)
tempnm <- NULL
if(timeExists && is.null(time)) {
temp <- tmp$dim$time$vals
s_time <- 1
e_time <- length(temp)
tempnm <- temp
}
if(!is.null(time)) {
errmsg = "'time' argument included, but input data has no time dimension"
stopifnot(errmsg = timeExists)
temp <- tmp$dim$time
# time inputs asDate
if(class(time) %in% "Date") {
time <- which(temp$vals %in% as.numeric(time - as.Date(origin)))
}
s_time <- time[1]
e_time <- s_time
if(length(time) == 2) e_time <- time[2] - s_time + 1
tempnm <- temp$vals[s_time:(s_time + e_time - 1)]
}
s_x <- 1
c_x <- -1
s_y <- 1
c_y <- -1
# set spatial mask
spatExists <- !is.null(spatial)
isPts <- FALSE
isMask <- FALSE
if(spatExists) {
isPts <- class(spatial) %in% "data.frame"
isMask <- class(spatial) %in% "RasterLayer"
}
mask2Extent <- raster::extentFromCells(spatial, raster::Which(!is.na(spatial), cell = TRUE))
mask_count_x <- (mask2Extent@xmax - mask2Extent@xmin) / resx
mask_count_x
mask_count_y <- (mask2Extent@ymax - mask2Extent@ymin) / resy
mask_count_y
s_x <- which(min(abs(mask2Extent@xmin - x)) == abs(mask2Extent@xmin - x))
s_x <- s_x[length(s_x)]
s_x
# correct if mask is the same size as input ncdf
e_x <- s_x + min(mask_count_x, length(tmp$dim$lon$vals) - 1)
e_x
436-427
0.5/9
x[e_x] - x[s_x]
(x[e_x] - x[s_x]) / (e_x - s_x)
s_x <- which(min(abs(mask2Extent@xmin - x)) == abs(mask2Extent@xmin - x))
s_x <- s_x[length(s_x)]
# correct if mask is the same size as input ncdf
e_x <- s_x + min(mask_count_x, length(tmp$dim$lon$vals) - 1)
s_y <- which(min(abs(mask2Extent@ymax - y)) == abs(mask2Extent@ymax - y))
s_y <- s_y[length(s_y)]
# correct if mask is the same size as input ncdf
e_y <- s_y + min(mask_count_y, length(tmp$dim$lat$vals) - 1)
y[e_y] - y[s_y]) / (e_y - s_y)
(y[e_y] - y[s_y]) / (e_y - s_y)
c_x <- e_x - s_x
c_y <- e_y - s_y
varid <- names(tmp$var)
if(!is.null(varName)) varid <- varName
from <- c(s_x, s_y)
counts <- c(c_x, c_y)
if(timeExists) {
from <- c(from, s_time)
counts <- c(counts, e_time)
}
arr <- ncdf4::ncvar_get(tmp, varid = varid, start = from, count = counts)
arr
dim(arr)
arrDims <- dim(arr)
time_arrDim <- NULL
if(timeExists) {
if(is.null(time)) {
time_arrDim <- length(arrDims)
} else if (length(time) > 1) {
time_arrDim <- length(arrDims)
}
}
temporal_sum <- FALSE
if(!is.null(temporal_fun) && !is.null(time_arrDim) && !isPts) { # ignore points
n <- dim(arr)[time_arrDim]
rast_tmp <- stack(lapply(seq_len(n), function(i) {
raster(getAxis(array = arr, idx = i, axis = time_arrDim))
}))
# 'sum', 'mean', 'sd', 'cv'
naMask <- is.na(rast_tmp[[1]])
if(temporal_fun == "sum") rast_tmp <- sum(rast_tmp, na.rm = TRUE)
if(temporal_fun == "mean") rast_tmp <- sum(rast_tmp, na.rm = TRUE) / n
if(temporal_fun == "sd") {
m <-  sum(rast_tmp, na.rm = TRUE) / n
rast_tmp <- sum((rast_tmp - m) ^ 2, na.rm = TRUE) / n
}
if(temporal_fun == "cv") {
m <-  sum(rast_tmp, na.rm = TRUE) / n
rast_tmp <- sum((rast_tmp - m) ^ 2, na.rm = TRUE) / n
rast_tmp <- rast_tmp / m
}
rast_tmp[naMask] <- NA
arr <- as.array(matrix(getValues(rast_tmp), nrow = rast_tmp@nrows, ncol = rast_tmp@ncols, byrow = TRUE))
tempnm <- NULL
# arrDims <- dim(arr)
# if(is.null(time)) {
#   time_arrDim <- length(arrDims)
# } else if (length(time) > 1) {
#   time_arrDim <- length(arrDims)
# }
temporal_sum <- TRUE
}
xmn = x[s_x]# - 0.5 * resx
xmx = x[e_x]# + 0.5 * resx
ymn = y[e_y]# - 0.5 * resy
ymx = y[s_y]#  + 0.5 * resy
xmx-xmn
dim(arr)
4.5/9
tmprast <- raster::crop(spatial, raster::extent(xmn, xmx, ymn, ymx))
mask2array <- matrix(raster::getValues(tmprast), byrow = TRUE, nrow = tmprast@nrows, ncol = tmprast@ncols)
#mask2array <- as.matrix(raster::crop(spatial, raster::extent(xmn, xmx, ymn, ymx)))
if(transpose) mask2array <- raster::t(mask2array)
if(!is.null(time_arrDim)) mask2array <- array(rep(mask2array, dim(arr)[time_arrDim]), dim = dim(arr))
arr <- mask2array * arr
arr
iter <- 1
if(!is.null(time_arrDim) && !temporal_sum) iter <- seq_len(dim(arr)[time_arrDim])
l = 1
if(!is.null(time_arrDim)) {
arr2rast <- as.matrix(getAxis(array = arr, idx = l, axis = time_arrDim))
#if(time_arrDim == 2) arr2rast <- raster::t(arr2rast)
} else {
arr2rast <- as.matrix(arr)
#if(isPts) arr2rast <- raster::t(arr2rast)
}
if(transpose) arr2rast <- raster::t(arr2rast)
seq_len(length(x_ext)
)
if(isMask) {
xmn = x[s_x] - 0.5 * resx
xmx = x[e_x] + 0.5 * resx
ymn = y[e_y] - 0.5 * resy
ymx = y[s_y]  + 0.5 * resy
}
xmx - xmn
xmn = x[s_x]# - 0.5 * resx
if(isMask) {
xmn = x[s_x]# - 0.5 * resx
xmx = x[e_x]# + 0.5 * resx
ymn = y[e_y]# - 0.5 * resy
ymx = y[s_y]#  + 0.5 * resy
}
rast <- raster::raster(arr2rast, xmn = xmn, xmx = xmx, ymn = ymn, ymx = ymx, crs = raster::crs(crs))
rast
xmn
spatial
plot(spatial)
plot(rast)
rast@extent
rast@extent <- spatial@extent
rast
mask2Extent
devtools::document("c:/users/fridman/documents/GitHub/cwatm4r")
devtools::load_all("c:/users/fridman/documents/GitHub/cwatm4r")
#library(cwatm4r)
library(raster)
pthin <- "c:/Users/fridman/Dropbox/IIASA/cwatm-dataCollection/Israel_1km/CWATM_data/climate/GSWP3-W5E5_1990-2019/"
pthout <- "c:/Users/fridman/Dropbox/IIASA/cwatm-dataCollection/Israel_1km/CWATM_data/climate/GSWP3-W5E5/"
# load basemap
fls <- list.files(pthin, full.names = TRUE)[1]
basemap_pth <- "c:/Users/fridman/Dropbox/IIASA/cwatm-dataCollection/Israel_1km/CWATM_data/cwatm_input30sec/routing/ldd.nc"
basemap <- cwatm4r::ncdf2raster(basemap_pth, transpose = TRUE) > 0
fle_tmplt <-cwatm4r::ncdf2raster(fls, time = 1, transpose = TRUE)
# aggregate basemap
basemap <- aggregate(basemap, mean(res(fle_tmplt) / res(basemap))) > 0
vars <- na.omit(unique(unlist(lapply(strsplit(list.files(pthin), split = "_"), `[`, 3))))
#var <- vars[1]
print(var)
fls <- list.files(pthin, pattern = var, full.names = TRUE)
x <- unlist(lapply(fls[2], function(fle) {
cwatm4r::ncdf2raster(pth = fle, transpose = TRUE, spatial = basemap, time = c(1, 10))
}), recursive = FALSE)
x
devtools::document("c:/users/fridman/documents/GitHub/cwatm4r")
devtools::load_all("c:/users/fridman/documents/GitHub/cwatm4r")
#library(cwatm4r)
library(raster)
pthin <- "c:/Users/fridman/Dropbox/IIASA/cwatm-dataCollection/Israel_1km/CWATM_data/climate/GSWP3-W5E5_1990-2019/"
pthout <- "c:/Users/fridman/Dropbox/IIASA/cwatm-dataCollection/Israel_1km/CWATM_data/climate/GSWP3-W5E5/"
# load basemap
fls <- list.files(pthin, full.names = TRUE)[1]
basemap_pth <- "c:/Users/fridman/Dropbox/IIASA/cwatm-dataCollection/Israel_1km/CWATM_data/cwatm_input30sec/routing/ldd.nc"
basemap <- cwatm4r::ncdf2raster(basemap_pth, transpose = TRUE) > 0
fle_tmplt <-cwatm4r::ncdf2raster(fls, time = 1, transpose = TRUE)
# aggregate basemap
basemap <- aggregate(basemap, mean(res(fle_tmplt) / res(basemap))) > 0
vars <- na.omit(unique(unlist(lapply(strsplit(list.files(pthin), split = "_"), `[`, 3))))
#var <- vars[1]
#cwatm4r::ncdfInfo(fls, attrs = TRUE)
#pth = fls[2]; transpose = TRUE; spatial = basemap; time = c(1, 2); flip = NULL; fun = NULL; temporal_fun = NULL; origin = "1900-01-01";crs = "+init=EPSG:4326";varName = NULL
for(var in vars) {
print(var)
fls <- list.files(pthin, pattern = var, full.names = TRUE)
x <- unlist(lapply(fls[2], function(fle) {
cwatm4r::ncdf2raster(pth = fle, transpose = TRUE, spatial = basemap)
}), recursive = FALSE)
#write file
inf <- cwatm4r::ncdfInfo(pth = fls[1], attrs = TRUE, dim = FALSE)
#
#
#in
cwatm4r::raster2ncdf(rast_in = x, path_out = sprintf("%s/gswp3-w5e5_obsclim_%s_daily_1990_2019.nc", pthout, var),
name = var, is_ncdf4 = FALSE,
time = as.numeric(names(x)),
origin = "1900-01-01",
unit = inf$varAttributes.units, prec = "double", missing_value =  320000,
longname = inf$varAttributes.long_name,
institute = "IIASA", title = "CWatM-Israel: climate inputs")
}
# circles dashboard
# circles available: resLake, groundwater, channel,wwt, consumption
#tmp load dependencies
rm(list = ls())
require(plotly)
require(ggplot2)
require(raster)
library(sf)
#library(cwatm4r)
devtools::document("c:/users/fridman/documents/GitHub/cwatm4r")
devtools::load_all("c:/users/fridman/documents/GitHub/cwatm4r")
source("c:/Users/fridman/Dropbox/IIASA/r_circles/rcircles_functions2.R")
# r_circles global - temporary (from dashboard)
# channel is now a problem
pths <- c("c:/Users/fridman/Dropbox/IIASA/cwatm_Israel/outputs/newModel_test/")
#pths <- c("c:/Users/fridman/Downloads/sa_mikhail/")
# "c:/Users/fridman/Dropbox/IIASA/cwatm_Israel/outputs/ayalon_WWTOnNoUrbRunoff/",
# "c:/Users/fridman/Dropbox/IIASA/cwatm_Israel/outputs/ayalonWWTOn/",
# "c:/Users/fridman/Dropbox/IIASA/cwatm_Israel/outputs/ayalonWWTOnIncIrr/",
# "c:/Users/fridman/Dropbox/IIASA/cwatm_Israel/outputs/ayalonWWTOnUrbRunOffLess/")
basin_name <- "ayalon" # sorek, ayalon, sorekAyalon
# getOutputString(modflow = TRUE, wwt = TRUE, extWater = FALSE,
#                 collect_recharge = FALSE, wadit = FALSE, limitAbst = TRUE)
outlet <- list("ayalon" =  c(34.795, 32.0873),
"sorek" = c(34.7043, 31.9457),
"sorekAyalon" = data.frame("x" = c(34.795, 34.7123), "y" = c(32.0873, 31.9374)))
# circle ="main"  () groundwater, wwt , resLake, channel, soil, consumption)
# check resLake balance and storage for all lakes - bet zayit is ok. check where is it on the map
### CREATE WADIT == TRUE DATASET FOR CIRCLES
buildCircle(circle = NULL,#c("main", "resLake", "channel", "groundwater"),#c("main", "soil"), # main, groundwater, resLake, consumption, wwt,  soil, channel | c("consumption", "wwt", "resLake")
dataPath = pths[1],
modflow = TRUE,
collect_recharge = FALSE,
wastewater = TRUE,
wadit = FALSE,
extWater = FALSE,
limitAbst = FALSE,
timeCons = NULL,#as.Date(c("2000-01-03", "2000-02-01")),#NULL, #as.Date(c("2001-01-01", "2001-12-31")), #c("2003-06-01", "2004-05-31"),
#spatial = data.frame("x" = 34.953, "y" = 31.762),
spatial = NULL,#data.frame("x" = 34.9542,"y" = 31.8704),
outlet = outlet[[basin_name]],
printBalance = TRUE)
#timeCons = c("2001-04-02", "2002-01-20"))
# Compare discharge
rm(list = ls())
gc()
require(plotly)
require(ggplot2)
require(raster)
#library(hydroGOF)
devtools::document("c:/users/fridman/documents/GitHub/cwatm4r")
devtools::load_all("c:/users/fridman/documents/GitHub/cwatm4r")
# check overflow form all wwt - e.g. Bet Shemesh; also check base flow and capillar location; also check with reduced aquifer size
KGE <- function(o,s) {
nans <- is.na(o)
o <- o[!nans]
s <- s[!nans]
B <- mean(s, na.rm = TRUE) / mean(o, na.rm = TRUE)
y <- (sd(s, na.rm = TRUE) / mean(s, na.rm = TRUE)) / (sd(o, na.rm = TRUE) / mean(o, na.rm = TRUE))
r <- cor(s, o, method = "pearson")
kge <- 1 -((r - 1) ^ 2 + (B - 1) ^ 2 + (y - 1) ^ 2)
return(kge)
}
NSE <- function(o,s, normalize = TRUE) {
nse <- 1 - sum((o - s) ^ 2, na.rm = TRUE) / sum((o - mean(o, na.rm = TRUE)) ^ 2, na.rm = TRUE)
if(normalize) {
nse <- 1 / (2 - nse)
}
return(nse)
}
#pth <-  "c:/Users/dof19/Dropbox/IIASA/cwatm_Israel/outputs/ayalonModflow_151221"
#pth <-  "c:/Users/dof19/Dropbox/IIASA/cwatm_Israel/outputs/SorekAyalonWadit/"
#pth <- "c:/Users/dof19/Dropbox/IIASA/cwatm_Israel/outputs/soreq_131221/"
#pth <- "c:/Users/dof19/Dropbox/IIASA/cwatm_Israel/outputs/modflow_checkStorage/"
pth <- "c:/Users/fridman/Dropbox/IIASA/cwatm_Israel/outputs/newModel_test/"
obs <- openxlsx::read.xlsx("c:/Users/fridman/Dropbox/IIASA/cwatm-dataCollection/Israel_1km/CWATM_data/cwatm_input30sec/calibration_data/daily_discharge_metaIncluded.xlsx",
sheet = 1, startRow = 2)
obsloc <- data.frame("x" = c(34.996, 34.754, 34.78, 34.845, 34.795, 34.862, #18115: 34.996
34.904, 34.917, 34.905),
"y" = c(31.755, 31.87, 31.837, 31.812, 32.037, 32.003, #18115: 31.755
31.962, 31.895, 31.987),
"sid" = c(18115, 18150, 18146, 18131, 17168, 17164,
17144, 17143, 17155))
#obsloc <- obsloc[obsloc$sid %in% c(18131, 18150, 18115), ] # sorek
obsloc <- obsloc[obsloc$sid %in% c(17168, 17164, 17144), ] # ayalon #
#obsloc <- obsloc[obsloc$sid %in% c(17168, 17164, 17144, 17155, 18131, 18150, 18115), ] # ayalonsorek
#period <- (c("2003-06-01", "2006-05-31"))
period <- NULL
# 18146 - can't get the discharge from the model due to spatial resolution.
# 18115 - may be off due to missed river pumping
x <- cwatm4r::ncdf2raster(pth = sprintf("%s/discharge_daily.nc", pth), transpose = TRUE,
spatial = obsloc, time = period, origin = "1901-01-01")
x$sid <- rep(obsloc$sid, nrow(x) /nrow(obsloc))
obs1 <- obs[obs$StationId %in% obsloc$sid, ]
x$date <- as.Date(as.numeric(x$time), origin = "1901-01-01")
obs1$time <- as.numeric(as.Date(paste0(obs1$Year, "-",obs1$Mon, "-", obs1$Day), "%Y-%m-%d") - as.Date("1901-01-01"))
obs1$pk <- paste(obs1$StationId, obs1$time, sep = "_")
x$pk <- paste(x$sid, x$time, sep = "_")
names(x)[5] <- "sim_val"
names(obs1)[5] <- "obs_val"
df <- merge(x, obs1[c(1, 5, 11)], all.x = TRUE, sort = FALSE, by = "pk")
df$difference <- df$sim_val - df$obs_val
df <- tidyr::gather(df, key, absolute, sim_val, obs_val)
df <- tidyr::gather(df, ds, val, absolute, difference)
df[df$ds %in% "difference", "key"] <- "difference"
## df wet season - 11 - 4 ###
df[!format(as.Date(df$time, "1901-01-01"), format = "%m") %in% c("10", "11", "12", "01", "02", "03", "04"), "val"] <- NA
setNames(unlist(lapply(unique(df$sid), function(id) {
tmp <- tidyr::spread(df[df$sid %in% id & df$ds %in% "absolute", ], key, val)
KGE(s = tmp$sim_val, o = tmp$obs_val)
#hydroGOF::KGE(sim = tmp$sim_val, obs = tmp$obs_val, method = "2009")
})), unique(df$sid))
setNames(unlist(lapply(unique(df$sid), function(id) {
tmp <- tidyr::spread(df[df$sid %in% id & df$ds %in% "absolute", ], key, val)
round(NSE(s = tmp$sim_val, o = tmp$obs_val), 3)
#hydroGOF::KGE(sim = tmp$sim_val, obs = tmp$obs_val, method = "2009")
})), unique(df$sid))
setNames(unlist(lapply(unique(df$sid), function(id) {
tmp <- tidyr::spread(df[df$sid %in% id & df$ds %in% "absolute", ], key, val)
summary(lm(sim_val~obs_val, data = tmp))$r.squared
})), unique(df$sid))
dplyr::summarise(dplyr::group_by(df[df$ds %in% "absolute", ], sid, ds, key),
"mean" = mean(val, na.rm = TRUE),
"median" = median(val, na.rm = TRUE),
"q75" = quantile(val, prob = 0.75, na.rm = TRUE))
# ggplot(df, aes(x = date, y =  val, color = key), alpha = 0.75) + geom_line(aes(group = key)) +
#   facet_wrap(ds~sid, scales = "free_y", ncol = length(unique(df$sid))) +
#   theme_light() + scale_x_date("Date", "6 months")
## CHECK CONVERSION FOR POINTS NOT THE RIGHT POINTS
ids <- obsloc$sid
figs <- lapply(ids, function(id) {
df_ <- tidyr::spread(df[df$sid %in% id & df$ds %in% "absolute", c("date", "key", "val")], key, val)
fig <- plot_ly(df_,
type = 'scatter', mode = 'lines',
x = ~date, y = ~sim_val, name = "Simulated")
fig <- add_trace(fig, x = ~date, y = df_$obs_val, type = 'scatter', mode = 'markers', name = "Observed")
fig <- layout(fig, yaxis = list(title = TeX("Avg.~Daily~Discharge~(m^{3}~sec^{-1})")),
xaxis = list(title = "Date"))
config(fig, mathjax = 'cdn')
})
multifig <- do.call("subplot", c(figs, list(nrows = length(figs))))
multifig <- layout(multifig,
annotations = lapply(seq_along(figs), function(i) {
list(x = 0.5,
y = 1 - (i - 1) * 1 / length(figs) - 0.03,
text =  sprintf("Station id: %s", ids[i]),
xref = "paper",
yref = "paper",
xanchor = "center",
yanchor = "bottom",
showarrow = FALSE )
}))
multifig
# #fig
#
# ggplot(tidyr::spread(df[!df$ds %in% "difference", ], key, val), aes(x = date)) +
#   geom_line(aes(y = sim_val)) + geom_point(aes(y = obs_val), color = "red") +
#   facet_wrap(ds~sid, scales = "free_y", nrow = length(unique(df$sid)))# + ylim(0, 1)
#
# df$year <- format(df$date, "%Y")
# ggplot(tidyr::spread(df[!df$ds %in% "difference", ], key, val), aes(x = obs_val, y =  sim_val,
#                                                                     color = as.factor(year))) + geom_point(alpha = 0.25) +
#   geom_abline(intercept = 0, slope = 1) +
#   facet_grid(sid~year, scales = "free_y") +
#   theme_light() + xlim(NA, 50) + ylim(NA, 50)
#
#
# ## weekely
#
# df$week <- format(df$date, "%W-%Y")
# df2 <- as.data.frame(summarise(group_by(df, week, sid, ds, key),
#                               "val" = mean(val, na.rm = TRUE)))
#
# setNames(unlist(lapply(unique(df2$sid), function(id) {
#   tmp <- tidyr::spread(df2[df2$sid %in% id & df2$ds %in% "absolute", ], key, val)
#   KGE(s = tmp$sim_val, o = tmp$obs_val)
# })), unique(df$sid))
#
# ggplot(df2[!df2$key %in% "difference", ], aes(x = week, y =  val, color = key)) + geom_line(aes(group = key)) +
#   facet_wrap(ds~sid, scales = "free_y", ncol = 1) +
#   theme_light()
# # df$monYear <- format(as.Date(df$time, origin = "1901-01-01"), format = "%b-%Y")
# # kge <- setNames(unlist(lapply(unique(df2$sid), function(id) {
# #   tmp <- tidyr::spread(df2[df2$sid %in% id, ], key, val)
# #   KGE(sim = tmp$sim_val, obs = tmp$obs_val)
# # })), unique(df$sid))
# #
# #
# # df2 <- as.data.frame(dplyr::summarise(dplyr::group_by(df, monYear, sid, key), "val" = mean(val, na.rm = TRUE)))
# # ggplot(df2, aes(x = monYear, y =  val, color = key)) + geom_line(aes(group = key)) + facet_grid(sid~., scales = "free_y")
# #
# #
# # #dm <- mean(stack(cwatm4r::ncdf2raster(sprintf("%s/discharge_daily.nc", pth), flip = NULL, transpose = TRUE)))
# #writeRaster(dm, "discharge_Sorekmean.tif", overwrite = TRUE)
